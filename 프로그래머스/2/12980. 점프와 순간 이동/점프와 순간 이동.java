// K칸을 앞으로 점프 or (현재까지 온 거리) * 2에 해당하는 위치로 순간이동할 수 있는 특수한 기능을 가진 아이언 슈트 개발
// K칸 점프 -> K칸만큼 건전지 사용량 소모
// 거리가 N만큼 떨어져 있는 장소로 가려고 함.
// 점프를 최소로 해야함.

// 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수
// 처음 위치에서 0에서 2칸을 앞으로 점프한 다음 순간이동 하면 건전지 사용량이 3만큼 듭니다. 
// 0에서 1칸을 앞으로 점프한 다음 순간이동하면 사용량 2만큼 듭니다. 

// 위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2

// 제한 사항 : N 은 10억 이하의 자연수 , K는 1 이상의 자연수

import java.util.*;

public class Solution {
    public int solution(int n) {
        // 1 -> +1
        // 2 -> +1,*2
        
        // 3 -> +1,*2,+1 -> 2
        
        // 4 -> +1,*2,*2 -> 1
        
        // 5 -> +1,*2,*2,+1 -> 2
        // 6 -> +1,*2,+1,*2 -> 2
        // 7 -> +1,*2,+1,*2,+1 -> 3
        
        // 8 -> +1,*2,*2,*2 -> 1
        
        // 9 -> +1,*2,*2,*2,+1 -> 2
        // 10 -> +1,*2,*2,+1,*2 -> 2
        // 11 -> +1,*2,*2,+1,*2,+1 -> 3
        // 12 -> +1,*2,+1,*2,*2 -> 2
        // 13 -> 12 -> 6 -> 3 -> 2 -> 1 -> 0
        
        // 13 -> +1,*2,+1,*2,*2,+1 -> 3
        // 14 -> +1,*2,+1,*2,+1,*2 -> 3
        // 15 -> +1,*2,+1,*2,+1,*2,+1 -> 4
        
        // 16 -> +1,*2,*2,*2,*2 -> 1
        // 5000 -> 1250 -> 625 -> 625 -1 -> 624 -> 312 -> 156 -> 78 -> 39 -> 38 -> 19 -> 18 -> 9 -> 8 -> 4 -> 2 -> 1 -> 0
        int count = 0;
        while(n > 0) {
            if(n % 2 == 0) {
                n /= 2;
            } else {
                n -= 1;
                count++;
            }
        }
        
        
        
        return count;
    }
}